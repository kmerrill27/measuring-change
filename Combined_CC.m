% ColorChecker values: LAB_L LAB_A LAB_B
colorChecker = [96.85, -0.92,   1.65; %(1,1)
    49.80, -0.01,   0.73; %(2,1)
    9.50,  0.69,   1.26; %(3,1)
    96.61, -0.92,   1.72;
    49.76,  0.01,   0.75;
    8.97,  0.67,   1.28;
    96.66, -0.94,   1.69;
    49.76,  0.01,   0.77;
    9.30,  0.83,   1.39;
    96.72, -0.94,   1.66;
    49.77, -0.00,   0.77;
    9.61,  0.77,   1.24;
    49.77,  0.00,   0.77;
    96.64, -0.94,   1.70; %(14,1)
    9.15,  0.72,   1.30; %(1,2)
    31.72, 51.18, -13.45;
    22.47, 18.93, -18.08;
    84.75, -1.53,  -7.06;
    32.15, 16.62,  20.64;
    63.26, 16.36,  19.78;
    47.53, -1.69, -22.93;
    38.58, -17.90, 31.33;
    52.44,	11.80,	-25.89;
    69.96,	-33.51,	2.57;
    84.76,	9.34,	16.84;
    21.11,	32.93,	6.44;
    40.46,	59.33,	7.34; %(14,2)
    49.67,	-0.00,	0.80; %(1,3)
    50.26,	0.10,	0.55;
    61.12,	27.05,	-18.95;
    42.73,	22.17,	-36.35;
    84.95,	13.84,	0.19;
    59.72,	35.73,	69.01;
    36.92,	17.95,	-48.02;
    46.40,	50.38,	17.89;
    22.30,	31.37,	-27.81;
    71.23,	-27.68,	67.43;
    68.72,	16.81,	77.63;
    90.55,	-16.87,	7.60;
    40.75,	64.45,	44.84;
    18.60,	30.21,	-8.08;
    8.08,	1.10,	0.26;
    96.67,	-0.90,	1.73;
    30.48,	50.90,	-40.06;
    21.67,	4.39,	-33.45;
    85.71,	-18.27,	0.70;
    22.26,	28.56,	-55.20;
    53.00,	-45.71,	42.05;
    34.66,	61.44,	34.33;
    79.71,	-0.63,	91.05;
    47.52,	54.58,	-17.90;
    49.73,	-28.42,	-26.14;
    84.88,	5.03,	-5.31;
    60.04,	34.93,	2.58;
    37.98,	62.84,	28.73;
    96.65,	-0.92,	1.73;
    9.00,	0.46,	1.20;
    51.85,	-8.91,	-44.71;
    61.93,	-14.84,	-28.45;
    85.30,	12.30,	6.49;
    96.83,	-0.88,	1.62;
    79.98,	0.33,	0.40;
    65.78,	0.08,	0.27;
    49.86,	-0.01,	0.71;
    35.90,	0.13,	0.31;
    17.72,	0.08,	-0.58;
    84.78,	-12.90,	-7.02;
    60.72,	33.71,	16.13;
    50.49,	65.60,	44.78;
    49.80,	-0.04,	0.74;
    49.78,	-0.05,	0.73;
    62.33,	-26.96,	-22.84;
    21.28,	-16.32,	-17.54;
    84.43,	-12.50,	27.76;
    7.91,	0.61,	-0.07;
    31.38,	0.11,	-0.06;
    40.97,	0.05,	0.04;
    60.95,	0.20,	0.05;
    75.73,	0.31,	0.35;
    89.34,	-0.32,	0.08;
    71.28,	0.09,	0.20;
    60.20,	49.33,	74.51;
    79.82,	20.79,	85.55;
    7.90,	0.68,	-0.28;
    96.83,	-0.89,	1.63;
    20.64,	-26.50,	-2.93;
    62.11,	-2.45,	-30.64;
    61.04,	28.71,	34.92;
    76.55,	18.81,	21.91;
    64.01,	11.27,	26.66;
    43.74,	13.85,	26.89;
    67.38,	11.85,	17.31;
    44.40,	24.84,	37.76;
    63.19,	23.95,	25.35;
    46.21,	0.11,	0.63;
    71.68,	-11.26,	89.17;
    80.88,	3.02,	96.22;
    96.83,	-0.90,	1.68;
    7.69,	0.53,	0.48;
    61.75,	-39.92,	-8.63;
    52.50,	-48.44,	-5.07;
    64.17,	17.24,	19.03;
    72.80,	27.65,	23.13;
    64.35,	11.88,	17.42;
    64.56,	14.29,	16.92;
    64.62,	13.78,	18.96;
    35.86,	14.28,	26.29;
    65.41,	19.83,	27.57;
    21.78,	0.42,	0.14;
    61.55,	0.92,	56.68;
    71.18,	-18.94,	77.40;
    49.68,	-0.03,	0.76;
    49.91,	-0.01,	0.68;
    22.17,	1.17,	8.88;
    61.49,	-40.92,	24.00;
    51.58,	-53.26,	18.23;
    21.69,	-23.25,	8.57;
    61.29,	-44.47,	12.02;
    61.06,	-30.38,	42.66;
    51.85,	-50.00,	47.24;
    62.25,	-53.19,	49.61;
    60.94,	14.64,	49.68;
    61.71,	-15.11,	55.62;
    71.92,	-29.23,	75.74;
    20.29,	13.52,	16.08;
    8.14,	0.74,	-0.08;
    96.75,	-0.91,	1.73;
    49.86,	-0.05,	0.70;
    7.53,	0.99,	0.39;
    96.80,	-0.93,	1.66;
    49.94,	-0.05,	0.70;
    7.54,	1.24,	0.48;
    96.77,	-0.94,	1.75;
    49.89,	-0.07,	0.70;
    7.52,	1.23,	0.44;
    96.79,	-0.94,	1.71;
    49.93,	-0.04,	0.72;
    7.92,	1.15,	0.22;
    49.72,	0.05,	0.75;
    96.85,	-0.95,	1.78;];

clearvars cropped;
cropped = 0;

filename = input('Enter an image filename:', 's');
rgb = imread(filename);

% Detect bright circles in given radius ranges
[centersA, radiiA] = imfindcircles(rgb, [20, 45], 'ObjectPolarity', 'bright');
[centersB, radiiB] = imfindcircles(rgb, [45, 70], 'ObjectPolarity', 'bright');
[centersC, radiiC] = imfindcircles(rgb, [70, 100], 'ObjectPolarity', 'bright');

% Merge circles found in two ranges
allCenters = [centersA; centersB; centersC];
allRadii = [radiiA; radiiB; radiiC];

if (size(allCenters, 1) < 3)
    disp('ColorChecker not found (A). Please select manually, cropping from the centers of the white circles.');
    cropped = imcrop(rgb);
    rotation = input('Rotate Image? (0, 90, 180, -90):');
    cropped = imrotate(cropped, rotation);
else

    % Select three strongest circles in image
    centers = allCenters(1:3,:);
    radii = allRadii(1:3);

    % Display outlines of found circles
    imshow(rgb);
    viscircles(allCenters, allRadii, 'EdgeColor', 'b');

    xCoords = centers(:, 1);
    yCoords = centers(:, 2);

    twoMinX = false;
    twoMinY = false;

    a = xCoords(1);
    b = xCoords(2);
    c = xCoords(3);
    d = yCoords(1);
    e = yCoords(2);
    f = yCoords(3);

    % Calculate acceptable error term for difference between circles in same
    % column/row due to orientation issues
    errorTerm = 30;

    if (abs(a-b) < errorTerm)
        if (a < c)
            twoMinX = true; % else 2 max x
        end
    elseif (abs(b-c) < errorTerm)
        if (b < a)
            twoMinX = true; % else 2 max x
        end
    elseif (abs(a-c) < errorTerm)
        if (a < b)
            twoMinX = true; % else 2 max x
        end
    else
        disp('ColorChecker not found (B). Please select manually, cropping from the centers of the white circles.');
        cropped = imcrop(rgb);
        rotation = input('Rotate Image? (0, 90, 180, -90):');
        cropped = imrotate(cropped, rotation);
    end

    if (abs(d-e) < 30)
        if (d < f)
            twoMinY = true; % else 2 max y
        end
    elseif (abs(e-f) < 30)
        if (e < d)
            twoMinY = true; % else 2 max y
        end
    elseif (abs(d-f) < 30)
        if (d < e)
            twoMinY = true; % else 2 max y
        end
    else
        if (cropped == 0)
            disp('ColorChecker not found (C). Please select manually, cropping from the centers of the white circles');
            cropped = imcrop(rgb);
            rotation = input('Rotate Image? (0, 90, 180, -90):');
            cropped = imrotate(cropped, rotation);
        end
    end
end
   
if (cropped == 0)
    minX = min(xCoords);
    maxX = max(xCoords);
    minY = min(yCoords);
    maxY = max(yCoords);

    % Crop out ColorChecker
    rect = [minX, minY, maxX - minX, maxY - minY];
    cropped = imcrop(rgb, rect);

    % Check for orientation of ColorChecker and rotate image if necessary
    if ((twoMinX == false) && (twoMinY == false)) % upside down
        cropped = imrotate(cropped, 180);
        disp('rotated 180');
    elseif ((twoMinX == false) && (twoMinY == true)) % right rotated
        cropped = imrotate(cropped, -90);
        disp('rotated -90');
    elseif ((twoMinX == true) && (twoMinY == false)) % left rotated
        cropped = imrotate(cropped, 90);
        disp('rotated 90');
    end
end
    
imwrite(cropped, 'temp.jpeg');

% Create mask
bwIm = im2bw(cropped);

a = size(bwIm);

% m X n is the dimension of the image - n=width, m=height
height = a(1);
width = a(2);

% Arrays to hold accumulate output data.
squareSize = [];
squareCoord = [];

%counts the number of successful hits (found white pixel)
counter = 0;

% Makes 100 attempts to randomly find white pixels in image
% Assumes the white pixel is part of a square and finds its size, position
for i=1:100
    %generating random numbers, to find white pixels.
    row = randi([1, height]);
    col = randi([1, width]);
    if bwIm(row, col) == 1
        pixX = row;
        pixY = col;
        currentX = pixX;
        currentY = pixY;
        
        % Finding the extreme coordinates of the square to calculate size.
        while (currentX > 0) && (bwIm(currentX, currentY) == 1)
            currentX=currentX-1;
        end
        if (currentX <= 0)
            continue;
        end
        minimumX = currentX;
        
        currentX = pixX;
        currentY = pixY;
        while (currentX < height) && (bwIm(currentX, currentY) == 1)
            currentX=currentX+1;
        end
        if (currentX >= height)
            continue;
        end
        maximumX = currentX;
        
        currentX = pixX;
        currentY = pixY;
        while (currentY > 0) && (bwIm(currentX, currentY) == 1)
            currentY=currentY-1;
        end
        if (currentY <= 0)
            continue;
        end
        minimumY = currentY;
        
        currentX = pixX;
        currentY = pixY;
        while (currentY < width) && (bwIm(currentX, currentY) == 1)
            currentY=currentY+1;
        end
        if (currentY >= width)
            continue;
        end
        maximumY = currentY;
        
        % making the calculations and appending to accumulator matrix.
        sides = [maximumX-minimumX ; maximumY - minimumY];
        center = [round((maximumY+minimumY)/2); round((maximumX+minimumX)/2)];
        squareSize = [squareSize, sides];
        squareCoord = [squareCoord, center];
        counter = counter + 1;
    end
end

numSquares = size(squareSize, 2)
sumSizes = 0;
for i=1:counter
    sumSizes = sumSizes + (squareSize(1, i) + squareSize(2, i))/2;
end
averageSize = sumSizes/counter;
sumSizes = 0;
count = 0;

% removing trivial size values which make average faulty
for i=1:counter
    if  (squareSize(1, i) + squareSize(2, i))/2 > averageSize/2
        sumSizes = sumSizes + (squareSize(1, i) + squareSize(2, i))/2;
        count = count + 1;
    end
end
averageSize = round(sumSizes/count);
averageSize

xySections = [];
aveRgb = [];
labVals = [];

j = 1;
for i=1:numSquares
    xSquareCoord = squareCoord(j);
    ySquareCoord = squareCoord(j+1);
    % Get x-coordinate (col) at which RHS black border begins
    % Approach from RHS to avoid white numbers in LHS border
    column = width;
    r = ySquareCoord;
    while (r < height) && (bwIm(r, column) < 0.5)
        if (width - column) > averageSize
            r = r-averageSize;
            column = width;
        else
            column = column-1;
        end
    end
    
    % Get approximate width of ColorChecker minus black borders
    ccWidth = width - ((width - column) * 2);
    widthBlock = ccWidth / 14;
    
    % Get y-coordinate (row) at which top black border ends
    rowB = 1;
    c = xSquareCoord;
    while (c < width) && (bwIm(rowB, c) < 0.5)
        if rowB > averageSize
            c = c+averageSize;
            rowB = 1;
        else
            rowB = rowB+1;
        end
    end
    
    % Get approximate height of ColorChecker minus black borders
    ccHeight = height - (rowB * 2);
    heightBlock = ccHeight / 10;
    
    % Get xy "sections" of given square in ColorChecker grid
    % e.g. 2,4 signifies the square in the second column and fourth row
    xySections = [xySections; (ceil((xSquareCoord - (width - column)) / widthBlock)), (ceil((ySquareCoord - rowB) / heightBlock))];
    
    % Get LAB values of given ColorChecker square based on grid mapping
    labVals = [labVals; colorChecker(xySections(j) + (14 * (xySections(j+1) - 1)), :, :)];
    
    % Get average rgb values for each square
    roi = [xSquareCoord-(averageSize/3), ySquareCoord-(averageSize/3), averageSize/3, averageSize/3];
    roiRect = imcrop(cropped, roi);
    aveRgb = [aveRgb; mean(mean(roiRect(:,:,1))), mean(mean(roiRect(:,:,2))), mean(mean(roiRect(:,:,3)))];
    
    j=j+2;
end